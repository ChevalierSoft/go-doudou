package dao

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/jmoiron/sqlx"
	"github.com/pkg/errors"
	"{{.DomainPackage}}"
	"github.com/unionj-cloud/go-doudou/kit/ddl/query"
	"github.com/unionj-cloud/go-doudou/kit/pathutils"
	"github.com/unionj-cloud/go-doudou/kit/templateutils"
	"math"
)

type {{.DomainName}}DaoImpl struct {
	db *sqlx.DB
}

func New{{.DomainName}}Dao(db *sqlx.DB) {{.DomainName}}Dao {
	return {{.DomainName}}DaoImpl{
		db: db,
	}
}

func (receiver {{.DomainName}}DaoImpl) Insert{{.DomainName}}(ctx context.Context, {{.DomainName | ToLower}} *domain.{{.DomainName}}) (int64, error) {
	var (
		statement    string
		err          error
		result       sql.Result
		{{- if .PkCol.Autoincrement }}
		lastInsertID int64
		{{- end }}
	)
	if statement, err = templateutils.StringBlockMysql(pathutils.Abs("{{.DomainName | ToLower}}dao.sql"), "Insert{{.DomainName}}", nil); err != nil {
		return 0, err
	}
	if result, err = receiver.db.NamedExecContext(ctx, statement, {{.DomainName | ToLower}}); err != nil {
		return 0, errors.Wrap(err, "error returned from calling db.Exec")
	}
	{{- if .PkCol.Autoincrement }}
	if lastInsertID, err = result.LastInsertId(); err != nil {
		return 0, errors.Wrap(err, "error returned from calling result.LastInsertId")
	}
	if lastInsertID > 0 {
		{{.DomainName | ToLower}}.{{.PkField.Name}} = int(lastInsertID)
	}
	{{- end }}
	return result.RowsAffected()
}

// With ON DUPLICATE KEY UPDATE, the affected-rows value per row is 1 if the row is inserted as a new row,
// 2 if an existing row is updated, and 0 if an existing row is set to its current values.
// If you specify the CLIENT_FOUND_ROWS flag to the mysql_real_connect() C API function when connecting to mysqld,
// the affected-rows value is 1 (not 0) if an existing row is set to its current values.
// https://dev.mysql.com/doc/refman/5.7/en/insert-on-duplicate.html
func (receiver {{.DomainName}}DaoImpl) Upsert{{.DomainName}}(ctx context.Context, {{.DomainName | ToLower}} *domain.{{.DomainName}}) (int64, error) {
	var (
		statement    string
		err          error
		result       sql.Result
		{{- if .PkCol.Autoincrement }}
		lastInsertID int64
		{{- end }}
	)
	if statement, err = templateutils.StringBlockMysql(pathutils.Abs("{{.DomainName | ToLower}}dao.sql"), "Upsert{{.DomainName}}", nil); err != nil {
		return 0, err
	}
	if result, err = receiver.db.NamedExecContext(ctx, statement, {{.DomainName | ToLower}}); err != nil {
		return 0, errors.Wrap(err, "error returned from calling db.Exec")
	}
	{{- if .PkCol.Autoincrement }}
	if lastInsertID, err = result.LastInsertId(); err != nil {
		return 0, errors.Wrap(err, "error returned from calling result.LastInsertId")
	}
	if lastInsertID > 0 {
		{{.DomainName | ToLower}}.{{.PkField.Name}} = int(lastInsertID)
	}
	{{- end }}
	return result.RowsAffected()
}

func (receiver {{.DomainName}}DaoImpl) Upsert{{.DomainName}}NoneZero(ctx context.Context, {{.DomainName | ToLower}} *domain.{{.DomainName}}) (int64, error) {
	var (
		statement    string
		err          error
		result       sql.Result
		{{- if .PkCol.Autoincrement }}
		lastInsertID int64
		{{- end }}
	)
	if statement, err = templateutils.StringBlockMysql(pathutils.Abs("{{.DomainName | ToLower}}dao.sql"), "Upsert{{.DomainName}}NoneZero", {{.DomainName | ToLower}}); err != nil {
		return 0, err
	}
	if result, err = receiver.db.ExecContext(ctx, statement); err != nil {
		return 0, errors.Wrap(err, "error returned from calling db.Exec")
	}
	{{- if .PkCol.Autoincrement }}
	if lastInsertID, err = result.LastInsertId(); err != nil {
		return 0, errors.Wrap(err, "error returned from calling result.LastInsertId")
	}
	if lastInsertID > 0 {
		{{.DomainName | ToLower}}.{{.PkField.Name}} = int(lastInsertID)
	}
	{{- end }}
	return result.RowsAffected()
}

func (receiver {{.DomainName}}DaoImpl) Delete{{.DomainName}}s(ctx context.Context, where query.Q) (int64, error) {
	var (
		statement string
		err       error
		result    sql.Result
	)
	statement = fmt.Sprintf("delete from {{.TableName}} where %s;", where.Sql())
	if result, err = receiver.db.ExecContext(ctx, statement); err != nil {
		return 0, errors.Wrap(err, "error returned from calling db.ExecContext")
	}
	return result.RowsAffected()
}

func (receiver {{.DomainName}}DaoImpl) Update{{.DomainName}}(ctx context.Context, {{.DomainName | ToLower}} *domain.{{.DomainName}}) (int64, error) {
	var (
		statement string
		err       error
		result    sql.Result
	)
	if statement, err = templateutils.StringBlockMysql(pathutils.Abs("{{.DomainName | ToLower}}dao.sql"), "Update{{.DomainName}}", nil); err != nil {
		return 0, err
	}
	if result, err = receiver.db.NamedExecContext(ctx, statement, {{.DomainName | ToLower}}); err != nil {
		return 0, errors.Wrap(err, "error returned from calling db.Exec")
	}
	return result.RowsAffected()
}

func (receiver {{.DomainName}}DaoImpl) Update{{.DomainName}}NoneZero(ctx context.Context, {{.DomainName | ToLower}} *domain.{{.DomainName}}) (int64, error) {
	var (
		statement string
		err       error
		result    sql.Result
	)
	if statement, err = templateutils.StringBlockMysql(pathutils.Abs("{{.DomainName | ToLower}}dao.sql"), "Update{{.DomainName}}NoneZero", {{.DomainName | ToLower}}); err != nil {
		return 0, err
	}
	if result, err = receiver.db.ExecContext(ctx, statement); err != nil {
		return 0, errors.Wrap(err, "error returned from calling db.Exec")
	}
	return result.RowsAffected()
}

func (receiver {{.DomainName}}DaoImpl) Update{{.DomainName}}s(ctx context.Context, {{.DomainName | ToLower}} domain.{{.DomainName}}, where query.Q) (int64, error) {
	var (
		statement string
		err       error
		result    sql.Result
	)
	if statement, err = templateutils.StringBlockMysql(pathutils.Abs("{{.DomainName | ToLower}}dao.sql"), "Update{{.DomainName}}s", struct {
		domain.{{.DomainName}}
		Where string
	}{
		{{.DomainName}}:  {{.DomainName | ToLower}},
		Where: where.Sql(),
	}); err != nil {
		return 0, err
	}
	if result, err = receiver.db.ExecContext(ctx, statement); err != nil {
		return 0, errors.Wrap(err, "error returned from calling db.Exec")
	}
	return result.RowsAffected()
}

func (receiver {{.DomainName}}DaoImpl) Update{{.DomainName}}sNoneZero(ctx context.Context, {{.DomainName | ToLower}} domain.{{.DomainName}}, where query.Q) (int64, error) {
	var (
		statement string
		err       error
		result    sql.Result
	)
	if statement, err = templateutils.StringBlockMysql(pathutils.Abs("{{.DomainName | ToLower}}dao.sql"), "Update{{.DomainName}}sNoneZero", struct {
		domain.{{.DomainName}}
		Where string
	}{
		{{.DomainName}}:  {{.DomainName | ToLower}},
		Where: where.Sql(),
	}); err != nil {
		return 0, err
	}
	if result, err = receiver.db.ExecContext(ctx, statement); err != nil {
		return 0, errors.Wrap(err, "error returned from calling db.Exec")
	}
	return result.RowsAffected()
}

func (receiver {{.DomainName}}DaoImpl) Get{{.DomainName}}(ctx context.Context, {{.PkField.Name | ToLower}} {{.PkField.Type}}) (domain.{{.DomainName}}, error) {
	var (
		statement string
		err       error
		{{.DomainName | ToLower}}      domain.{{.DomainName}}
	)
	if statement, err = templateutils.StringBlockMysql(pathutils.Abs("{{.DomainName | ToLower}}dao.sql"), "Get{{.DomainName}}", nil); err != nil {
		return domain.{{.DomainName}}{}, err
	}
	if err = receiver.db.GetContext(ctx, &{{.DomainName | ToLower}}, receiver.db.Rebind(statement), {{.PkField.Name | ToLower}}); err != nil {
		return domain.{{.DomainName}}{}, errors.Wrap(err, "error returned from calling db.Select")
	}
	return {{.DomainName | ToLower}}, nil
}

func (receiver {{.DomainName}}DaoImpl) Select{{.DomainName}}s(ctx context.Context, where query.Q) ([]domain.{{.DomainName}}, error) {
	var (
		statement string
		err       error
		{{.DomainName | ToLower}}s     []domain.{{.DomainName}}
	)
	statement = fmt.Sprintf("select * from {{.TableName}} where %s", where.Sql())
	if err = receiver.db.SelectContext(ctx, &{{.DomainName | ToLower}}s, statement); err != nil {
		return nil, errors.Wrap(err, "error returned from calling db.SelectContext")
	}
	return {{.DomainName | ToLower}}s, nil
}

func (receiver {{.DomainName}}DaoImpl) Count{{.DomainName}}s(ctx context.Context, where query.Q) (int, error) {
	var (
		statement string
		err       error
		total     int
	)
	statement = fmt.Sprintf("select count(1) from {{.TableName}} where %s", where.Sql())
	if err = receiver.db.GetContext(ctx, &total, statement); err != nil {
		return 0, errors.Wrap(err, "error returned from calling db.GetContext")
	}
	return total, nil
}

func (receiver {{.DomainName}}DaoImpl) Page{{.DomainName}}s(ctx context.Context, where query.Q, page query.Page) (query.PageRet, error) {
	var (
		statement string
		err       error
		{{.DomainName | ToLower}}s     []domain.{{.DomainName}}
		total     int
	)
	statement = fmt.Sprintf("select * from {{.TableName}} where %s %s;", where.Sql(), page.Sql())
	if err = receiver.db.SelectContext(ctx, &{{.DomainName | ToLower}}s, statement); err != nil {
		return query.PageRet{}, errors.Wrap(err, "error returned from calling db.SelectContext")
	}

	statement = fmt.Sprintf("select count(1) from {{.TableName}} where %s;", where.Sql())
	if err = receiver.db.GetContext(ctx, &total, statement); err != nil {
		return query.PageRet{}, errors.Wrap(err, "error returned from calling db.GetContext")
	}

	pageRet := query.NewPageRet(page)
	pageRet.Items = {{.DomainName | ToLower}}s
	pageRet.Total = total

	if math.Ceil(float64(total)/float64(pageRet.PageSize)) > float64(pageRet.PageNo) {
		pageRet.HasNext = true
	}

	return pageRet, nil
}
